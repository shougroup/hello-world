# The first ~270 lines are the annotated functions
# See lines 270+ for annotated execution code

############################################
#####		Km Analysis Functions		####
############################################
require(plyr); require(ggplot2); require(zoo); require(drc);

# time series = intensity data over time/slices for one strain growing at one concentration

# for a time series, normalizes mean intensity by first time point and returns the log
normInt<-function(timeseries){
	 timeseries$normlog<-log(timeseries$mean/timeseries$mean[1])
	 timeseries}

# Breaks up a dataframe into the individual time series by factors in lst (works on KmDataAgg + list of factors eg. .(strain,conc))
# then normalizes column named "mean" to first timepoint for each time series by applying normInt into a new column called normlog
normIntByFactor<-function(df,lst)ddply(df,lst,normInt)

#for a time series, selects all time points where intensity <= p * maximum intensity
up2max<-function(df,p) df[which(df$mean<= max(df$mean)*p),]

#Applies up2max to each combination of strain & concentration
get2max<-function(df,lst,p)ddply(df,lst,up2max,p)

# calculates sum of squared residuals for a linear model
residsum<-function(y){sum(resid(lm(normlog~hrs,data=as.data.frame(y)))^2)} # sum of squared residuals from linear model

# returns slope of linear model
lmcoefs<-function(y){coef(lm(normlog~hrs,data=as.data.frame(y)))[2]} # sum of squared residuals from linear model

#for a time series (strain+conc), finds window of n time-points with the best linear model fit
bestwindow<-function(df,n,p){ # finds best linear window fit with window size n
	if(length(df$mean[df$mean<(max(df$mean,rm.na=TRUE)*p)])>=n){	# Skip model if mean doesn't go up 1/p fold
		b<-up2max(df,p) #remove time-points with intensities > p * maximum intensity
		residsums <-rollapply(b[,c("normlog","hrs")],n,residsum,by.column=FALSE) #find sum of squared resids for each sliding window of size n
		a<-which(residsums==min(residsums)) # starting time point of best fit window
		df[a:(a+n-1),] #get the window
	}
	else{NA}
}

#for a time series (strain+conc), finds window of n time-points with steepest slope
steepestwindow<-function(df,n,p){ # finds best linear window fit with window size n
	if(length(df$mean[df$mean<(max(df$mean,rm.na=TRUE)*p)])>=n){	# Skip model if mean doesn't go up 1/p fold
		b<-up2max(df,p) #remove time-points with intensities > p * maximum intensity
		slopes <-rollapply(b[,c("normlog","hrs")],n,lmcoefs,by.column=FALSE) #find sum of squared resids for each sliding window of size n
		a<-which(slopes==max(slopes)) # starting time point of best fit window
		df[a:(a+n-1),] #get the window
	}
	else{NA}
}

#Generates dataframe with residsums for each window sized n for each growth curve
windowresids<-function(df,n){ 
		if(dim(df)[1]<n){ residsums <-NA}
		else{residsums <-rollapply(df[,c("normlog","hrs")],n,residsum,by.column=FALSE)}
		residsums
}

# finds window size n, where all growth curves are most linear 
findBestOverallWindow<-function(df,p,n){    
	
	concwndw<-NULL
	
	#df<-get2max(df,p) #currently intensity threshold parameter is deactivated
    #split into list of strain~conc dataframes
    lst1<-dlply(df,.(conc))
    
    for(i in names(lst1)){    #for each item in lst
    	wndw<-list()
    	lst2<-dlply(lst1[[i]],.(strain,rep))
    	
    	for(j in names(lst2)){ 
			wndw[[j]]<-windowresids(lst2[[j]],n) #find best window and store it in the wndw object           
		}
		
		wndw<-ldply(wndw)
		rownames(wndw)<-wndw[,1]
		wndw<-wndw[,-1]
		
		bestwnd<-which(apply(wndw,2,sum)==min(apply(wndw,2,sum))):(which(apply(wndw,2,sum)==min(apply(wndw,2,sum)))+n-1)
		concwndw<-rbind(concwndw,bestwnd)
    }
    rownames(concwndw)<-names(lst1)
    concwndw
}

# Given tile-averaged KmData, returns object with 3 subobjects 
# $results: a dataframe of best fit parameters for each strain~concentration combination
# $wndw: a list of dataframes, each being the best fit window used to generate $results for each strain~concentration combination
# $model: a list of lm model objects, each being the best fit model for each strain~concentration combination
CalcGR<-function(df,p=1,n,method="maximum"){    
    
    #setting up output object
	wndw=list()
	out<-NULL
    model<-list()
    results <- data.frame(strain=character(), conc=numeric(), rep=character(),logintrcpt=numeric(), logintrcptErr=numeric(), g.rate=numeric(), g.rateErr=numeric(), d.time=numeric(), stringsAsFactors=FALSE) 
  
	# if method = "maximum" find window with steepest slope
	if(identical(method, "maximum")){
		lst<-dlply(df,.(strain,rep,conc))
	
		for(i in names(lst)){    #for each item in lst 
			strain=substr(i,1,gregexpr("\\.",i)[[1]][1]-1)	#extracts strain from the name of the list item generated by dlply
			rep=substr(i,gregexpr("\\.",i)[[1]][1]+1,gregexpr("\\.",i)[[1]][2]-1) #extracts replicate
			conc=substring(i,gregexpr("\\.",i)[[1]][2]+1) #extracts concentration from the name of the list item by dlply
			
			if(!is.na(steepestwindow(lst[[i]],n,p))){ #if a best window can be found
				wndw[[i]]<-steepestwindow(lst[[i]],n,p) #find best window of size n below max*p and store it in the wndw object
				model[[i]]<-lm(normlog~hrs,wndw[[i]]) #fit the model and store it in the model object
				results[i,]<-c(strain,conc,rep,summary.lm(model[[i]])$coef[1,1],summary.lm(model[[i]])$coef[1,2],summary.lm(model[[i]])$coef[2,1],summary.lm(model[[i]])$coef[2,2],log(2)/summary.lm(model[[i]])$coef[2,1])
			}
			else{ #if no window can be fitted set values to NA
				wndw[[i]]<-NA
				model[[i]]<-NA
				results[i,]<-c(strain,rep,conc,NA,NA,NA,NA,NA)
			}
		}
	} else if(identical(method, "individual")){ # if method = "individual" find window with lowest residuals
		lst<-dlply(df,.(strain,rep,conc))
	
		for(i in names(lst)){    #for each item in lst
			strain=substr(i,1,gregexpr("\\.",i)[[1]][1]-1)	#extracts strain from the name of the list item generated by dlply
			rep=substr(i,gregexpr("\\.",i)[[1]][1]+1,gregexpr("\\.",i)[[1]][2]-1) #extracts replicate
			conc=substring(i,gregexpr("\\.",i)[[1]][2]+1) #extracts concentration from the name of the list item by dlply
			
			if(!is.na(bestwindow(lst[[i]],n,p))){ #if a best window can be found
				wndw[[i]]<-bestwindow(lst[[i]],n,p) #find best window of size n below max*p and store it in the wndw object
				model[[i]]<-lm(normlog~hrs,wndw[[i]]) #fit the model and store it in the model object
				results[i,]<-c(strain,conc,rep,summary.lm(model[[i]])$coef[1,1],summary.lm(model[[i]])$coef[1,2],summary.lm(model[[i]])$coef[2,1],summary.lm(model[[i]])$coef[2,2],log(2)/summary.lm(model[[i]])$coef[2,1])
			}
			else{ #if no window can be fitted set values to NA
				wndw[[i]]<-NA
				model[[i]]<-NA
				results[i,]<-c(strain,conc,rep,NA,NA,NA,NA,NA)
			}
		}
	} else{ # Else use specified window of timepoints or find best overall window
		 # if lengt of data points specified
		bestwnd<-NULL
		
		if(identical(method, "overall")){
			bestwnd<-findBestOverallWindow(df,p,n)
		} else{	
			for(i in 1:length(unique(df$conc))){
				bestwnd<-rbind(bestwnd,method:(method+n-1))
			}
			rownames(bestwnd)<-unique(as.character(df$conc))
		}
		#break df up by concentration
		lst<-dlply(df,.(conc))
		#select data for the overall best fit window for each concentration
		for (i in names(lst)){
			lst[[i]]<-lst[[i]][lst[[i]]$slice %in% bestwnd[i,],]
		}
		#put df back together, [,-1] removes the .id column generated by ldply
		df2<-ldply(lst)[,-1]	
		
		#break df up by strain & concentration
		lst<-dlply(df2,.(strain,rep,conc))
	
		for(i in names(lst)){    #for each item in lst
			strain=substr(i,1,gregexpr("\\.",i)[[1]][1]-1)	#extracts strain from the name of the list item generated by dlply
			rep=substr(i,gregexpr("\\.",i)[[1]][1]+1,gregexpr("\\.",i)[[1]][2]-1) #extracts replicate
			conc=substring(i,gregexpr("\\.",i)[[1]][2]+1) #extracts concentration from the name of the list item by dlply
			wndw[[i]]=lst[[i]]
			model[[i]]<-lm(normlog~hrs,wndw[[i]]) #fit the model and store it in the model object    
			results[i,]<-c(strain,conc,rep,summary.lm(model[[i]])$coef[1,1],summary.lm(model[[i]])$coef[1,2],summary.lm(model[[i]])$coef[2,1],summary.lm(model[[i]])$coef[2,2],log(2)/summary.lm(model[[i]])$coef[2,1])  
		}
	}
	    
    #set results columns as numeric and round them (i don't understand why 
    rownames(results)<-1:dim(results)[1]
    results[,4:8]<-round(apply(results[,4:8],2,as.numeric),3) # round all values 3 decimals
    out$results<-results
  	print(out$results) #print results to the screen
    out$window<-wndw #save windows
    out$model<-model #save models
    out #return results object    
}

#averages Results objects,takes named list of Results objects eg. lst<-list(A=A$results,B=B$results)
calcMeanGR<-function(lst1,.var){
	#combines the data from each replicate in the list into one big data frame
	df<-ldply(lst1) 
	#Averages g.rate & intercept values after splitting dataframes by factors in .var
	df2<-ddply(df,.var,summarize,mean.g.rate=mean(g.rate,na.rm=TRUE),sd.g.rate=sd(g.rate),mean.logintrcpt=mean(logintrcpt),sd.logintrcpt=sd(logintrcpt),n=length(logintrcpt))	
}	

# function extracts the coefficients from a dose-response mondel model
KmCoefs<-function(DRmodel){
		c(
			summary(DRmodel)$coefficients[1,1:2],		# "Vmax" & "Vmax.err"
			summary(DRmodel)$coefficients[2,1:2],		# "Km" & "Km.err"
			DRmodel$curve[[1]](1e6)/2					# half maximal growth rate (growth rate at 1e6 uM /2)
		)
	}

# calculate Km using michaelis-menten dose response model, if rmZero=TRUE removes 0uM data points before fitting Km
calcKm<-function(lst,.var,rmZero=FALSE){
	
	Km=NULL
	Km$models=list() # list of dose response models
	Km$result=data.frame() #data frame of Vmax & Km for each strain
	Km$preds=data.frame()  # predicted values for plotting Monod curves
	
	
	#combines the data from each replicate in the list into one big data frame
	Km$data<-ldply(lst)
	if(rmZero)Km$data<-Km$data[Km$data$conc!=0,]
	
	# split dataframe into list of time series by factors in .var
	lst1<-dlply(Km$data,.var)
	#lst1<-dlply(Km$data,.(strain))
	
	# Fit monod curves for each time series
	for(i in names(lst1)){
		tryCatch({  # prevents loop from exiting upon error
			Km$models[[i]]<-drm(g.rate~as.numeric(conc),data=lst1[[i]],fct=MM.2())  #fit data to Michaelis Menten dose response model, see drm()
			#lst2[[i]]<-nls(g.rate ~ Vm * conc/(K+conc),data=lst[[i]],start = list(K = max(lst[[i]]$g.rate)/2, Vm = max(lst[[i]]$g.rate)))  # nls() is another option, same result if they converge
		}, error=function(e)print(paste(i,"Km regression failed to converge")))
	}
	
	# extract vmax & Km for each model using KmCoefs()
	Km$results<-ldply(Km$models,KmCoefs)
	
	#formating results 
	Km$results[,2:6]<-round(apply(Km$results[,2:6],2,as.numeric),3) #make numeric & round to 3 digits
	colnames(Km$results)<-c("strain","Vmax","Vmax.err","Km","Km.err","half.max") #naming columns
	
	# getting data for plotting Monod curves (assigning plot() to a variable saves the data plotted)
	for(i in names(Km$models)){
		Km$preds<-rbind(Km$preds,cbind(rep(i,times=100),plot(Km$models[[i]])))
	}
	colnames(Km$preds)<-c("strain","conc","g.rate")
	dev.off()
	
	print(Km$results)
	return(Km)
}

#plots to identify/check anomalies (smudge, out of focus, etc)
screenTiles<-function(df,wells=NA){
	if(!is.na(wells)) df<-df[df$well %in% wells,]
	par(ask=TRUE)
	for(i in unique(df$well)){

		dat<- df[df$well==i,]
		print(i)
		mytheme = 	list(
						geom_line(),
						geom_point(),
						scale_y_log10(),
						ggtitle(paste(setup$lookup[setup$lookup$position==i,1:4]$position,setup$lookup[setup$lookup$position==i,1:4]$strain,setup$lookup[setup$lookup$position==i,1:4]$conc,setup$lookup[setup$lookup$position==i,1:4]$rep)),
						annotation_logticks(sides="l",size=0.2)
						)
		plt<-ggplot(data=dat, aes(x=slice, y=expTcorr_bs_intden, col=tile))+mytheme
		print(plt)
	}
	par(ask=FALSE)
}

############################################
#####			Execution 				####
############################################
#Future work:
#ability to remove individual timepoints to set to NA

#set the working directory and define output file name
setwd(setup$wd)
outfile=paste(setup$nutr,"_",setup$prestarve,"_",setup$date,"_","p=",setup$p,"_","n=",setup$n,"_","method=",setup$method,"_",setup$microscope,sep="")

#Make sure setup$lookup columns are in the right format
setup$lookup$position<-as.factor(setup$lookup$position)
setup$lookup$strain<-as.factor(setup$lookup$strain)
setup$lookup$rep<-as.factor(setup$lookup$rep)

#read in data
KmData<-read.table(setup$infile, header =TRUE)[,c("position","slice","min.elapsed","expTcorr_bs_intden")]
if(dim(KmData[KmData$expTcorr_bs_intden<0,])[1]>0) KmData[KmData$expTcorr_bs_intden<0,]$expTcorr_bs_intden=NA #set negative values to NA, bioact artifact

#remove last time point if incomplete
if(length(KmData[KmData$slice==max(KmData$slice),1])<length(KmData[KmData$slice==(max(KmData$slice)-1),1])){
	KmData<-KmData[KmData$slice<max(KmData$slice),]
}

# Add informative columns
KmData$well<-as.factor(substr(KmData$position,1,3)) # get well identifier
KmData$tile<-as.factor(substr(KmData$position,4,4)) #get tile letter
KmData$strain<-setup$lookup$strain[match(KmData$well,setup$lookup$position)] #replace with well position with strain
KmData$conc<-setup$lookup$conc[match(KmData$well,setup$lookup$position)] #replace with well position with concentration
KmData$rep<-setup$lookup$rep[match(KmData$well,setup$lookup$position)]
KmData<-KmData[!is.na(KmData$conc) &!is.na(KmData$strain),] #removes data not in the lookup table so you can use different lookup tables to leave out data

#Exclude images
if(length(setup$Set2NA)>0){KmData[KmData$position %in% setup$Set2NA,]$expTcorr_bs_intden=NA} #set desired tiles to NA
KmData<-KmData[!is.na(KmData$expTcorr_bs_intden),] #remove NA points with NA data

#plot intensity vs slice for each tile, used to find desired window and to exclude outlier tiles (out of focus etc)
if(exists("TileScreen")){if(TileScreen==1){screenTiles(KmData)}}
TileScreen=0

# Exclude time points
KmDataFull<-KmData
if(!is.null(setup$slices)){KmData<-KmData[KmData$slice %in% setup$slices,]} # only keep selected timepoints

head(KmData,n=20) 

#Averages data over tiles for each combination of slices, strain, and concentration
KmDataAgg<-ddply(KmData, .(strain,slice,conc,rep), summarize, mean = mean(expTcorr_bs_intden,na.rm = TRUE), sd = sd(expTcorr_bs_intden,na.rm = TRUE), logmean = log(mean(expTcorr_bs_intden,na.rm = TRUE)), hrs = round(mean(min.elapsed/60,na.rm = TRUE),1))
KmDataFullAgg<-ddply(KmDataFull, .(strain,slice,conc,rep), summarize, mean = mean(expTcorr_bs_intden,na.rm = TRUE), sd = sd(expTcorr_bs_intden,na.rm = TRUE), logmean = log(mean(expTcorr_bs_intden,na.rm = TRUE)), hrs = round(mean(min.elapsed/60,na.rm = TRUE),1))

#Normalize by starting intensity for each combination of strain and concentration
KmDataAgg<-normIntByFactor(KmDataAgg,.(strain,conc,rep))
KmDataFullAgg<-normIntByFactor(KmDataFullAgg,.(strain,conc,rep))

head(KmDataAgg,n=20)

#gets all timpoints up to the p*max for each strain
#KmDataAgg2max<-get2max(KmDataAgg,p)

#calculate linear models
Results<-CalcGR(KmDataAgg,p=setup$p,n=setup$n,method=setup$method)

#Estimates Km & Vmax via Michaelis-Menten dose-response model
Km<-calcKm(list(Results$results),.(strain))

write.table(KmDataAgg,file=paste(outfile,"_data.tab",sep=""),quote=FALSE,row.names=FALSE,sep="\t")
write.table(Results$results,file=paste(outfile,"_fits.tab",sep=""),quote=FALSE,row.names=FALSE,sep="\t")
write.table(Km$results,file=paste(outfile,"_Kms.tab",sep=""),quote=FALSE,row.names=FALSE,sep="\t")
save(setup,KmData,KmDataAgg,Results,Km,file=paste(outfile,".RData",sep=""))

####################################################
########			 Plotting 			   #########
####################################################

pdf(file=paste(outfile,"_plots.pdf",sep=""),width=10.5, height=8)
#gets data for the best fit window only (used for plotting the solid lines where growth rate was measured)
KmDataAggWindow<-ldply(Results$window[!is.na(Results$window)])[-1]

# Intensity vs time plots by strain for each concentration (full data)
# Doesn't work for some reason: KmDataAggWindow and KmDataFullAgg are shifted.
mytheme = 	list(
				#geom_line(linetype="dotted"),
				geom_point(size=1.5),
				facet_wrap(~conc,scales = "free_x"),
				xlab("time in hours"),
				ylab("normalized mean intensity across tiles"),
				scale_y_log10(),
				scale_color_manual(values=setup$colors,limits=setup$strains),
				ggtitle(paste("All data points: Growth at x uM ",setup$nutr,"by strain\n(p =",setup$p,"n =",setup$n,"method =",setup$method,")","\n",setup$infile,sep=" ")),
				annotation_logticks(sides="l",size=0.2),
				theme(legend.position="right",legend.text=element_text(size=6,face="bold"),plot.title = element_text(hjust = 0,size=10))
				)		
#ggplot(data=KmDataFullAgg, aes(x=hrs, y=exp(normlog) ,col=strain, shape=rep))+
#mytheme + geom_line(data=KmDataAggWindow)+
#annotate("rect",xmin=min(KmDataAgg$hrs,rm.na=TRUE),xmax=max(KmDataAgg$hrs,rm.na=TRUE),ymin=1,ymax=max(exp(KmDataAgg$normlog)), fill="blue",alpha=0.08)

# Intensity vs time plots by strain for each concentration (selected data)
mytheme = 	list(
				#geom_line(linetype="dotted"),
				geom_point( size=2,position=position_jitter(w=0.01)),
				facet_wrap(~conc,scales = "free_x"),
				xlab("time in hours"),
				ylab("normalized mean intensity across tiles"),
				scale_y_log10(),
				scale_color_manual(values=setup$colors,limits=setup$strains),
				ggtitle(paste("Data range used for analysis: Growth at x uM ",setup$nutr,"by strain\n(p =",setup$p,"n =",setup$n,"method =",setup$method,")","\n",setup$infile,sep=" ")),
				annotation_logticks(sides="l",size=0.2),
				theme(legend.position="right",legend.text=element_text(size=6,face="bold"),plot.title = element_text(hjust = 0,size=10))
				)		
ggplot(data=KmDataAgg, aes(x=hrs, y=exp(normlog) ,col=strain, shape=rep)) + mytheme + geom_line(data=KmDataAggWindow,)

# Intensity vs time plots by concentration for each strain (selected data)
mytheme = 	list(
				#geom_line(linetype="dotted"),
				geom_point(size=2,position=position_jitter(w=0.01)),
				facet_wrap(~strain,scales = "free_x"),
				xlab("time in hours"),
				ylab("normalized mean intensity across tiles"),
				scale_y_log10(),
				scale_color_manual(values=setup$colors),
				ggtitle(paste("Growth at x uM",setup$nutr,"\n(p =",setup$p,"n =",setup$n,"method =",setup$method,")","\n",setup$infile,sep=" ")),
				annotation_logticks(sides="l",size=0.2),
				theme(legend.position="right",legend.text=element_text(size=6,face="bold"),plot.title = element_text(hjust = 0,size=10)),
				labs(color=paste("uM",setup$nutr))
				)		
ggplot(data=KmDataAgg, aes(x=hrs, y=exp(normlog) ,color=as.factor(conc), shape=rep)) + mytheme + geom_line(data=KmDataAggWindow)

# Growth Rate vs Concentration plot (selected data)
mytheme = 	list(
				geom_line(linetype="dotted", size=0.2),
				geom_point(size=3,position=position_jitter(w=0.1)),
				xlab(paste("[",setup$nutr,"] in uM",sep="")),
				ylab("Growth Rate (1/hr)"),
				scale_color_manual(values=setup$colors,limits=setup$strains),
				ggtitle(paste("Growth Rate at x uM",setup$nutr,"\n(p =",setup$p,"n =",setup$n,"method =",setup$method,") Data Points are jittered but lines are not.","\n",setup$infile,sep=" ")),
				theme(legend.position="right",legend.text=element_text(size=7,face="bold"),plot.title=element_text(size=10,hjust = 0))
				)
ggplot(data=Results$results, aes(x=factor(conc,levels=as.numeric(unique(conc))), y=g.rate ,col=strain, group=strain, shape=rep)) + mytheme

#plotting Km curve
mytheme = 	list(
				xlab(paste("[",setup$nutr,"] in uM",sep="")),
				ylab("Growth Rate (1/hr)"),
				scale_x_log10(),
				annotation_logticks(sides="b",size=0.2),
				scale_color_manual(values=setup$colors,limits=setup$strains),
				ggtitle(paste(setup$nutr,"Predicted Monod Curves Curves & Km+/-fitting error at half.max)","\n(p =",setup$p,"n =",setup$n,"method =",setup$method,")",sep=" ")),
				theme(legend.position="right",legend.text=element_text(size=7,face="bold"),plot.title=element_text(size=10,hjust = 0))
				)

ggplot(data=Km$results,aes(x=Km,y=half.max,color=strain)) + mytheme+
geom_point(shape="X",size=3,aes(x=Km,y=half.max))+ 
geom_errorbarh(data=Km$results,aes(xmin=Km-Km.err,xmax=Km+Km.err,y=half.max,color=strain,height=0.01))+
geom_line(data=Km$preds, linetype="twodash",aes(x=conc, y=g.rate ,color=strain,group=strain))

dev.off()